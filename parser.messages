expression_eof: BIGLAMBDA OTHER_IDENTIFIER DOT TIMES 
##
## Ends in an error in state: 88.
##
## expression -> BIGLAMBDA identifier DOT . expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## BIGLAMBDA identifier DOT 
##

Parsing a type abstraction expression of the form "Lam ID. EXP",
we have parsed "Lam ID." and now expect an expression.

expression_eof: BIGLAMBDA OTHER_IDENTIFIER TRUE 
##
## Ends in an error in state: 87.
##
## expression -> BIGLAMBDA identifier . DOT expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## BIGLAMBDA identifier 
##

Parsing a type abstraction expression of the form "Lam ID. EXP",
we have parsed "Lam ID" and now expect a '.'.

expression_eof: BIGLAMBDA TRUE 
##
## Ends in an error in state: 86.
##
## expression -> BIGLAMBDA . identifier DOT expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## BIGLAMBDA 
##

Parsing a type abstraction expression of the form "Lam ID. EXP",
we have parsed "Lam" and now expect an identifier.

expression_eof: BLAME COLON LPAREN TIMES THEN 
##
## Ends in an error in state: 49.
##
## simple_expression -> BLAME COLON LPAREN typ . RPAREN [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## BLAME COLON LPAREN typ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production typ -> simple_typ 
##

Parsing a blame expression of the form "blame : (TYP)",
we have parsed "blame : (TYP" and now expect a ')'.

expression_eof: BLAME COLON LPAREN TRUE 
##
## Ends in an error in state: 48.
##
## simple_expression -> BLAME COLON LPAREN . typ RPAREN [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## BLAME COLON LPAREN 
##

Parsing a blame expression of the form "blame : (TYP)",
we have parsed "blame : (" and now expect a type.

expression_eof: BLAME COLON TRUE 
##
## Ends in an error in state: 47.
##
## simple_expression -> BLAME COLON . LPAREN typ RPAREN [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## BLAME COLON 
##

Parsing a blame expression of the form "blame : (TYP)",
we have parsed "blame :" and now expect a '('.

expression_eof: BLAME TRUE 
##
## Ends in an error in state: 46.
##
## simple_expression -> BLAME . COLON LPAREN typ RPAREN [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## BLAME 
##

Parsing a blame expression of the form "blame : (TYP)",
we have parsed "blame" and now expect a colon.

expression_eof: IF TIMES 
##
## Ends in an error in state: 44.
##
## expression -> IF . cast_expression THEN cast_expression ELSE cast_expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## IF 
##

Parsing an if expression of the form "if EXP then EXP else EXP",
we have parsed "if" and now expect an expression.

expression_eof: IF TRUE RPAREN 
##
## Ends in an error in state: 55.
##
## cast_expression -> cast_expression . COLON typ conv_lbl CAST typ [ THEN COLON ]
## cast_expression -> cast_expression . COLON typ CAST typ [ THEN COLON ]
## expression -> IF cast_expression . THEN cast_expression ELSE cast_expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## IF cast_expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 75, spurious reduction of production arith_expression -> app_expression 
## In state 72, spurious reduction of production cast_expression -> arith_expression 
##

Parsing an if expression of the form "if EXP then EXP else EXP",
we have parsed "if EXP" and now expect a "then", but encountered a ')'.

expression_eof: IF TRUE THEN TIMES 
##
## Ends in an error in state: 56.
##
## expression -> IF cast_expression THEN . cast_expression ELSE cast_expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## IF cast_expression THEN 
##

Parsing an if expression of the form "if EXP then EXP else EXP",
we have parsed "if EXP then" and now expect an expression.

expression_eof: IF TRUE THEN TRUE ELSE TIMES 
##
## Ends in an error in state: 58.
##
## expression -> IF cast_expression THEN cast_expression ELSE . cast_expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## IF cast_expression THEN cast_expression ELSE 
##

Parsing an if expression of the form "if EXP then EXP else EXP",
we have parsed "if EXP then EXP else" and now expect an expression.

expression_eof: IF TRUE THEN TRUE ELSE TRUE THEN 
##
## Ends in an error in state: 59.
##
## cast_expression -> cast_expression . COLON typ conv_lbl CAST typ [ RPAREN RANGLE IN EOF COMMA COLON ]
## cast_expression -> cast_expression . COLON typ CAST typ [ RPAREN RANGLE IN EOF COMMA COLON ]
## expression -> IF cast_expression THEN cast_expression ELSE cast_expression . [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## IF cast_expression THEN cast_expression ELSE cast_expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 75, spurious reduction of production arith_expression -> app_expression 
## In state 72, spurious reduction of production cast_expression -> arith_expression 
##

Parsed an if expression, but next encountered a "then". 
If the if expression is the condition of an outer if expression,
you should wrap it in parentheses.

expression_eof: IF TRUE THEN TRUE THEN 
##
## Ends in an error in state: 57.
##
## cast_expression -> cast_expression . COLON typ conv_lbl CAST typ [ ELSE COLON ]
## cast_expression -> cast_expression . COLON typ CAST typ [ ELSE COLON ]
## expression -> IF cast_expression THEN cast_expression . ELSE cast_expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## IF cast_expression THEN cast_expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 75, spurious reduction of production arith_expression -> app_expression 
## In state 72, spurious reduction of production cast_expression -> arith_expression 
##

Parsing an if expression of the form "if EXP then EXP else EXP",
we have parsed "if EXP then EXP" and now expect an "else".

expression_eof: LAMBDA LPAREN OTHER_IDENTIFIER COLON TIMES RPAREN DOT TIMES 
##
## Ends in an error in state: 43.
##
## expression -> LAMBDA LPAREN term_variable COLON typ RPAREN DOT . expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA LPAREN term_variable COLON typ RPAREN DOT 
##

Parsing a lambda expression of the form "lam (ID : TYP). EXP",
we have parsed "lam (ID : TYP)." and now expect an expression.

expression_eof: LAMBDA LPAREN OTHER_IDENTIFIER COLON TIMES RPAREN TRUE 
##
## Ends in an error in state: 42.
##
## expression -> LAMBDA LPAREN term_variable COLON typ RPAREN . DOT expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA LPAREN term_variable COLON typ RPAREN 
##

Parsing a lambda expression of the form "lam (ID : TYP). EXP",
we have parsed "lam (ID : TYP)" and now expect a '.'.

expression_eof: LAMBDA LPAREN OTHER_IDENTIFIER COLON TIMES THEN 
##
## Ends in an error in state: 41.
##
## expression -> LAMBDA LPAREN term_variable COLON typ . RPAREN DOT expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA LPAREN term_variable COLON typ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production typ -> simple_typ 
##

Parsing a lambda expression of the form "lam (ID : TYP). EXP",
we have parsed "lam (ID : TYP" and now expect a ')'.

expression_eof: LAMBDA LPAREN OTHER_IDENTIFIER COLON TRUE 
##
## Ends in an error in state: 40.
##
## expression -> LAMBDA LPAREN term_variable COLON . typ RPAREN DOT expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA LPAREN term_variable COLON 
##

Parsing a lambda expression of the form "lam (ID : TYP). EXP",
we have parsed "lam (ID :" and now expect a type.

expression_eof: LAMBDA LPAREN OTHER_IDENTIFIER TRUE 
##
## Ends in an error in state: 39.
##
## expression -> LAMBDA LPAREN term_variable . COLON typ RPAREN DOT expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA LPAREN term_variable 
##

Parsing a lambda expression of the form "lam (ID : TYP). EXP",
we have parsed "lam (ID" and now expect a colon.

expression_eof: LAMBDA LPAREN TRUE 
##
## Ends in an error in state: 38.
##
## expression -> LAMBDA LPAREN . term_variable COLON typ RPAREN DOT expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA LPAREN 
##

Parsing a lambda expression of the form "lam (ID : TYP). EXP",
we have parsed "lam (" and now expect an identifier.

expression_eof: LAMBDA TRUE 
##
## Ends in an error in state: 37.
##
## expression -> LAMBDA . LPAREN term_variable COLON typ RPAREN DOT expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA 
##

Parsing a lambda expression of the form "lam (ID : TYP). EXP",
we have parsed "lam" and now expect a '('.

expression_eof: LANGLE TIMES 
##
## Ends in an error in state: 36.
##
## simple_expression -> LANGLE . expression COMMA expression RANGLE [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LANGLE 
##

Parsing a pair expression of the form "<EXP, EXP>",
we have parsed "<" and now expect an expression.

expression_eof: LANGLE TRUE COMMA TIMES 
##
## Ends in an error in state: 93.
##
## simple_expression -> LANGLE expression COMMA . expression RANGLE [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LANGLE expression COMMA 
##

Parsing a pair expression of the form "<EXP, EXP>",
we have parsed "<EXP," and now expect an expression.

expression_eof: LANGLE TRUE COMMA TRUE RPAREN 
##
## Ends in an error in state: 94.
##
## simple_expression -> LANGLE expression COMMA expression . RANGLE [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LANGLE expression COMMA expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 75, spurious reduction of production arith_expression -> app_expression 
## In state 72, spurious reduction of production cast_expression -> arith_expression 
## In state 90, spurious reduction of production expression -> cast_expression 
##

Parsing a pair expression of the form "<EXP, EXP>",
we have parsed "<EXP, EXP" and now expect a '>'.

expression_eof: LANGLE TRUE RPAREN 
##
## Ends in an error in state: 92.
##
## simple_expression -> LANGLE expression . COMMA expression RANGLE [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LANGLE expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 75, spurious reduction of production arith_expression -> app_expression 
## In state 72, spurious reduction of production cast_expression -> arith_expression 
## In state 90, spurious reduction of production expression -> cast_expression 
##

Parsing a pair expression of the form "<EXP, EXP>",
we have parsed "<EXP" and now expect a ','.

expression_eof: LET OTHER_IDENTIFIER COLON TIMES EQUAL TIMES 
##
## Ends in an error in state: 35.
##
## expression -> LET term_variable COLON typ EQUAL . expression IN expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LET term_variable COLON typ EQUAL 
##

Parsing a let expression of the form "let ID : TYP = EXP in EXP",
we have parsed "let ID : TYP =" and now expect an expression.

expression_eof: LET OTHER_IDENTIFIER COLON TIMES EQUAL TRUE IN TIMES 
##
## Ends in an error in state: 97.
##
## expression -> LET term_variable COLON typ EQUAL expression IN . expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LET term_variable COLON typ EQUAL expression IN 
##

Parsing a let expression of the form "let ID : TYP = EXP in EXP",
we have parsed "let ID : TYP = EXP in" and now expect an expression.

expression_eof: LET OTHER_IDENTIFIER COLON TIMES EQUAL TRUE RPAREN 
##
## Ends in an error in state: 96.
##
## expression -> LET term_variable COLON typ EQUAL expression . IN expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LET term_variable COLON typ EQUAL expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 75, spurious reduction of production arith_expression -> app_expression 
## In state 72, spurious reduction of production cast_expression -> arith_expression 
## In state 90, spurious reduction of production expression -> cast_expression 
##

Parsing a let expression of the form "let ID : TYP = EXP in EXP",
we have parsed "let ID : TYP = EXP" and now expect an 'in'.

expression_eof: LET OTHER_IDENTIFIER COLON TIMES THEN 
##
## Ends in an error in state: 34.
##
## expression -> LET term_variable COLON typ . EQUAL expression IN expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LET term_variable COLON typ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production typ -> simple_typ 
##

Parsing a let expression of the form "let ID : TYP = EXP in EXP",
we have parsed "let ID : TYP" and now expect an '='.

expression_eof: LET OTHER_IDENTIFIER COLON TRUE 
##
## Ends in an error in state: 13.
##
## expression -> LET term_variable COLON . typ EQUAL expression IN expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LET term_variable COLON 
##

Parsing a let expression of the form "let ID : TYP = EXP in EXP",
we have parsed "let ID :" and now expect a type.

expression_eof: LET OTHER_IDENTIFIER TRUE 
##
## Ends in an error in state: 12.
##
## expression -> LET term_variable . COLON typ EQUAL expression IN expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LET term_variable 
##

Parsing a let expression of the form "let ID : TYP = EXP in EXP",
we have parsed "let ID" and now expect a colon.

expression_eof: LET TRUE 
##
## Ends in an error in state: 9.
##
## expression -> LET . term_variable COLON typ EQUAL expression IN expression [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LET 
##

Parsing a let expression of the form "let ID : TYP = EXP in EXP",
we have parsed "let" and now expect an identifier.

expression_eof: LPAREN TIMES 
##
## Ends in an error in state: 5.
##
## simple_expression -> LPAREN . expression RPAREN [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Parsing a parenthesized expression of the form "(EXP)",
we have parsed "(" and now expect an expression.

expression_eof: LPAREN TRUE RANGLE 
##
## Ends in an error in state: 99.
##
## simple_expression -> LPAREN expression . RPAREN [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 75, spurious reduction of production arith_expression -> app_expression 
## In state 72, spurious reduction of production cast_expression -> arith_expression 
## In state 90, spurious reduction of production expression -> cast_expression 
##

Parsing a parenthesized expression of the form "(EXP)",
we have parsed "(EXP" and now expect a ')'.

expression_eof: MINUS INTEGER TRUE 
##
## Ends in an error in state: 72.
##
## arith_expression -> arith_expression . PLUS arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . MINUS arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . TIMES arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . EQUAL arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## cast_expression -> arith_expression . [ THEN RPAREN RANGLE IN EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## arith_expression 
##

Parsing an arithmetic expression of the form "EXP OP EXP",
we have parsed "EXP" and now expect one of "+", "-", or "*".

expression_eof: MINUS TRUE 
##
## Ends in an error in state: 6.
##
## arith_expression -> MINUS . nat [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

Parsing a number of the form "-n",
we have parsed "-" and now expect a natural number.

expression_eof: PI1 TIMES 
##
## Ends in an error in state: 3.
##
## simple_expression -> PI1 . simple_expression [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## PI1 
##

Parsing a projection of the form "pi1 EXP",
we have parsed "pi1" and now expect an expression.

expression_eof: PI2 TIMES 
##
## Ends in an error in state: 2.
##
## simple_expression -> PI2 . simple_expression [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## PI2 
##

Parsing a projection of the form "pi2 EXP",
we have parsed "pi2" and now expect an expression.

expression_eof: TIMES 
##
## Ends in an error in state: 0.
##
## expression_eof' -> . expression_eof [ # ]
##
## The known suffix of the stack is as follows:
## 
##

The symbol * is either a type or an operation, not an expression.

expression_eof: TRUE COLON FORALL OTHER_IDENTIFIER DOT TRUE 
##
## Ends in an error in state: 20.
##
## typ -> FORALL identifier DOT . typ [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ]
##
## The known suffix of the stack is as follows:
## FORALL identifier DOT 
##

Parsing a forall type of the form "forall ID. TYP",
we have parsed "forall ID." and now expect a type.

expression_eof: TRUE COLON FORALL OTHER_IDENTIFIER TRUE 
##
## Ends in an error in state: 19.
##
## typ -> FORALL identifier . DOT typ [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ]
##
## The known suffix of the stack is as follows:
## FORALL identifier 
##

Parsing a forall type of the form "forall ID. TYP",
we have parsed "forall ID" and now expect a '.'.

expression_eof: TRUE COLON FORALL TRUE 
##
## Ends in an error in state: 18.
##
## typ -> FORALL . identifier DOT typ [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ]
##
## The known suffix of the stack is as follows:
## FORALL 
##

Parsing a forall type of the form "forall ID. TYP",
we have parsed "forall" and now expect an indentifier.

expression_eof: TRUE COLON LANGLE TIMES COMMA TIMES THEN 
##
## Ends in an error in state: 30.
##
## simple_typ -> LANGLE typ COMMA typ . RANGLE [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ARROW ]
##
## The known suffix of the stack is as follows:
## LANGLE typ COMMA typ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production typ -> simple_typ 
##

Parsing a pair type of the form "<TYP, TYP>",
we have parsed "<TYP, TYP" and now expect a '>'.

expression_eof: TRUE COLON LANGLE TIMES COMMA TRUE 
##
## Ends in an error in state: 29.
##
## simple_typ -> LANGLE typ COMMA . typ RANGLE [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ARROW ]
##
## The known suffix of the stack is as follows:
## LANGLE typ COMMA 
##

Parsing a pair type of the form "<TYP, TYP>",
we have parsed "<TYP," and now expect a type.

expression_eof: TRUE COLON LANGLE TIMES THEN 
##
## Ends in an error in state: 28.
##
## simple_typ -> LANGLE typ . COMMA typ RANGLE [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ARROW ]
##
## The known suffix of the stack is as follows:
## LANGLE typ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production typ -> simple_typ 
##

Parsing a pair type of the form "<TYP, TYP>",
we have parsed "<TYP" and now expect a ','.

expression_eof: TRUE COLON LANGLE TRUE 
##
## Ends in an error in state: 16.
##
## simple_typ -> LANGLE . typ COMMA typ RANGLE [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ARROW ]
##
## The known suffix of the stack is as follows:
## LANGLE 
##

Parsing a pair type of the form "<TYP, TYP>",
we have parsed "<" and now expect a type.

expression_eof: TRUE COLON LPAREN TIMES THEN 
##
## Ends in an error in state: 32.
##
## simple_typ -> LPAREN typ . RPAREN [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN typ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production typ -> simple_typ 
##

Parsing a parenthesized type of the form "(TYP)",
we have parsed "(TYP" and now expect a ')'.

expression_eof: TRUE COLON LPAREN TRUE 
##
## Ends in an error in state: 15.
##
## simple_typ -> LPAREN . typ RPAREN [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Parsing a parenthesized type of the form "(TYP)",
we have parsed "(" and now expect a type.

expression_eof: TRUE COLON TIMES ARROW TRUE 
##
## Ends in an error in state: 26.
##
## typ -> simple_typ ARROW . typ [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ]
##
## The known suffix of the stack is as follows:
## simple_typ ARROW 
##

Parsing an arrow type of the form "TYP -> TYP",
we have parsed "TYP ->" and now expect a type.

expression_eof: TRUE COLON TIMES CAST TRUE 
##
## Ends in an error in state: 67.
##
## cast_expression -> cast_expression COLON typ CAST . typ [ THEN RPAREN RANGLE IN EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## cast_expression COLON typ CAST 
##

Parsing a cast expression of the form "EXP : TYP => TYP",
we have parsed "EXP : TYP =>" and now expect a type.

expression_eof: TRUE COLON TIMES MINUS TRUE 
##
## Ends in an error in state: 65.
##
## conv_lbl -> MINUS . type_name [ CAST ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

Parsing a conversion label of the form "-ID",
we have parsed "-" and now expect an identifier.

expression_eof: TRUE COLON TIMES PLUS A_IDENTIFIER CAST TRUE 
##
## Ends in an error in state: 70.
##
## cast_expression -> cast_expression COLON typ conv_lbl CAST . typ [ THEN RPAREN RANGLE IN EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## cast_expression COLON typ conv_lbl CAST 
##

Parsing a cast expression of the form "EXP : TYP => TYP",
we have parsed "EXP : TYP" and now expect a "=>".

expression_eof: TRUE COLON TIMES PLUS A_IDENTIFIER TRUE 
##
## Ends in an error in state: 69.
##
## cast_expression -> cast_expression COLON typ conv_lbl . CAST typ [ THEN RPAREN RANGLE IN EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## cast_expression COLON typ conv_lbl 
##

Parsing a conversion expression of the form "EXP : TYP +ID=> TYP",
we have parsed "EXP : TYP +ID" and now expect a "=>".

expression_eof: TRUE COLON TIMES PLUS TRUE 
##
## Ends in an error in state: 62.
##
## conv_lbl -> PLUS . type_name [ CAST ]
##
## The known suffix of the stack is as follows:
## PLUS 
##

Parsing a conversion label of the form "+ID",
we have parsed "+" and now expect an identifier.

expression_eof: TRUE COLON TIMES THEN 
##
## Ends in an error in state: 61.
##
## cast_expression -> cast_expression COLON typ . conv_lbl CAST typ [ THEN RPAREN RANGLE IN EOF ELSE COMMA COLON ]
## cast_expression -> cast_expression COLON typ . CAST typ [ THEN RPAREN RANGLE IN EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## cast_expression COLON typ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production typ -> simple_typ 
##

Parsing either a conversion expression of the form "EXP : TYP +ID=> TYP",
or a cast expression of the form "EXP : TYP => TYP",
we have parsed "EXP : TYP" and now expect either a conversion label or a "=>".

expression_eof: TRUE COLON TIMES TRUE 
##
## Ends in an error in state: 25.
##
## typ -> simple_typ . ARROW typ [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ]
## typ -> simple_typ . [ THEN RPAREN RBRACKET RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON CAST ]
##
## The known suffix of the stack is as follows:
## simple_typ 
##

Parsing either a conversion expression of the form "EXP : TYP +ID=> TYP",
or a cast expression of the form "EXP : TYP => TYP",
we have parsed "EXP : TYP" and now expect either a conversion label or a "=>".

expression_eof: TRUE COLON TRUE 
##
## Ends in an error in state: 60.
##
## cast_expression -> cast_expression COLON . typ conv_lbl CAST typ [ THEN RPAREN RANGLE IN EOF ELSE COMMA COLON ]
## cast_expression -> cast_expression COLON . typ CAST typ [ THEN RPAREN RANGLE IN EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## cast_expression COLON 
##

Parsing either a conversion expression of the form "EXP : TYP +ID=> TYP",
or a cast expression of the form "EXP : TYP => TYP",
we have parsed "EXP :" and now expect a type.

expression_eof: TRUE EQUAL MINUS INTEGER TRUE 
##
## Ends in an error in state: 85.
##
## arith_expression -> arith_expression . PLUS arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . MINUS arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . TIMES arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . EQUAL arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression EQUAL arith_expression . [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## arith_expression EQUAL arith_expression 
##

Parsing an arithmetic expression of the form "EXP OP EXP",
we have parsed "EXP OP EXP" and encountered what looks like an application.
To perform arithmetic inside an application, please use parentheses.

expression_eof: TRUE EQUAL TIMES 
##
## Ends in an error in state: 84.
##
## arith_expression -> arith_expression EQUAL . arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## arith_expression EQUAL 
##

Parsing an arithmetic expression of the form "EXP OP EXP",
we have parsed "EXP OP" and now expect an expression.

expression_eof: TRUE LBRACKET TIMES THEN 
##
## Ends in an error in state: 77.
##
## app_expression -> app_expression LBRACKET typ . RBRACKET [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## app_expression LBRACKET typ 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production typ -> simple_typ 
##

Parsing an instantiation expression of the form "EXP [TYP]",
we have parsed "EXP [TYP" and now expect a ']'.

expression_eof: TRUE LBRACKET TRUE 
##
## Ends in an error in state: 76.
##
## app_expression -> app_expression LBRACKET . typ RBRACKET [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## app_expression LBRACKET 
##

Parsing an instantiation expression of the form "EXP [TYP]",
we have parsed "EXP [" and now expect a type.

expression_eof: TRUE MINUS MINUS INTEGER TRUE 
##
## Ends in an error in state: 83.
##
## arith_expression -> arith_expression . PLUS arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . MINUS arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression MINUS arith_expression . [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . TIMES arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . EQUAL arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## arith_expression MINUS arith_expression 
##

Parsing an arithmetic expression of the form "EXP OP EXP",
we have parsed "EXP OP EXP" and encountered what looks like an application.
To perform arithmetic inside an application, please use parentheses.

expression_eof: TRUE MINUS TIMES 
##
## Ends in an error in state: 82.
##
## arith_expression -> arith_expression MINUS . arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## arith_expression MINUS 
##

Parsing an arithmetic expression of the form "EXP OP EXP",
we have parsed "EXP OP" and now expect an expression.

expression_eof: TRUE PLUS MINUS INTEGER TRUE 
##
## Ends in an error in state: 81.
##
## arith_expression -> arith_expression . PLUS arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression PLUS arith_expression . [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . MINUS arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . TIMES arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
## arith_expression -> arith_expression . EQUAL arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## arith_expression PLUS arith_expression 
##

Parsing an arithmetic expression of the form "EXP OP EXP",
we have parsed "EXP OP EXP" and encountered what looks like an application.
To perform arithmetic inside an application, please use parentheses.

expression_eof: TRUE PLUS TIMES 
##
## Ends in an error in state: 80.
##
## arith_expression -> arith_expression PLUS . arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## arith_expression PLUS 
##

Parsing an arithmetic expression of the form "EXP OP EXP",
we have parsed "EXP OP" and now expect an expression.

expression_eof: TRUE RBRACKET 
##
## Ends in an error in state: 75.
##
## app_expression -> app_expression . LBRACKET typ RBRACKET [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
## app_expression -> app_expression . simple_expression [ TRUE TIMES THEN RPAREN RANGLE PLUS PI2 PI1 OTHER_IDENTIFIER MINUS LPAREN LBRACKET LANGLE INTEGER IN FALSE EQUAL EOF ELSE COMMA COLON CAP_IDENTIFIER BLAME A_IDENTIFIER ]
## arith_expression -> app_expression . [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## app_expression 
##

Unmatched ']'.

expression_eof: TRUE RPAREN 
##
## Ends in an error in state: 104.
##
## expression_eof -> expression . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 75, spurious reduction of production arith_expression -> app_expression 
## In state 72, spurious reduction of production cast_expression -> arith_expression 
## In state 90, spurious reduction of production expression -> cast_expression 
##

Unmatched ')'.

expression_eof: TRUE THEN 
##
## Ends in an error in state: 90.
##
## cast_expression -> cast_expression . COLON typ conv_lbl CAST typ [ RPAREN RANGLE IN EOF COMMA COLON ]
## cast_expression -> cast_expression . COLON typ CAST typ [ RPAREN RANGLE IN EOF COMMA COLON ]
## expression -> cast_expression . [ RPAREN RANGLE IN EOF COMMA ]
##
## The known suffix of the stack is as follows:
## cast_expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 75, spurious reduction of production arith_expression -> app_expression 
## In state 72, spurious reduction of production cast_expression -> arith_expression 
##

"then" occurs without preceding "if".

expression_eof: TRUE TIMES TIMES 
##
## Ends in an error in state: 73.
##
## arith_expression -> arith_expression TIMES . arith_expression [ TIMES THEN RPAREN RANGLE PLUS MINUS IN EQUAL EOF ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## arith_expression TIMES 
##

Parsing an arithmetic expression of the form "EXP OP EXP",
we have parsed "EXP OP" and now expect an expression.

